#Code:  pd_front_end.py

#=========================================================
#IMPORT STATEMENTS
#=========================================================

import sys
script,pardir,parfile,modelfile = sys.argv
import numpy as np
import scipy.interpolate
import scipy.ndimage
import os.path
import copy
import pdb,ipdb

from hyperion.model import Model
import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt
from hyperion.model import ModelOutput
import h5py
from analytics import stellar_sed_write

import yt
from yt.units.yt_array import YTQuantity

sys.path.insert(0,pardir)
par = __import__(parfile)
model = __import__(modelfile)


import config as cfg
cfg.par = par #re-write cfg.par for all modules that read this in now
cfg.model = model

from astropy.table import Table
from astropy.io import ascii
from astropy import units as u
from astropy import constants 


from front_ends.front_end_controller import stream
from grid_construction import yt_octree_generate,grid_coordinate_boost,grid_center
import SED_gen as sg
from find_order import *
import powderday_test_octree as pto
import hyperion_octree_stats as hos
import error_handling as eh
import backwards_compatibility as bc

from m_control_tools import *
from image_processing import add_transmission_filters
#=========================================================
#CHECK FOR THE EXISTENCE OF A FEW CRUCIAL FILES FIRST
#=========================================================

eh.file_exist(model.hydro_dir+model.Gadget_snap_name)
eh.file_exist(par.dustdir+par.dustfile)


#=========================================================
#Enforce Backwards Compatibility for Non-Critical Variables
#=========================================================
cfg.par.FORCE_RANDOM_SEED,cfg.par.BH_SED,cfg.par.IMAGING,cfg.par.SED,cfg.par.IMAGING_TRANSMISSION_FILTER,cfg.par.SED_MONOCHROMATIC,cfg.par.SKIP_RT,FIX_SED_MONOCHROMATIC_WAVELENGTHS,cfg.par.n_MPI_processes,cfg.par.SOURCES_RANDOM_POSITIONS = bc.variable_set()

#=========================================================
#GRIDDING
#=========================================================


print 'Octree grid is being generated by yt'

fname = cfg.model.hydro_dir+cfg.model.Gadget_snap_name
field_add,ds = stream(fname)

#figure out which tributary we're going to

ds_type = ds.dataset_type 
#define the options dictionary
options = {'gadget_hdf5':m_control_sph,
           'tipsy':m_control_sph,
           'enzo_packed_3d':m_control_enzo}

m_gen = options[ds_type]()
m,xcent,ycent,zcent,dx,dy,dz,pf,boost = m_gen(fname,field_add)





#Get dust wavelengths. This needs to preceed the generation of sources
#for hyperion since the wavelengths of the SEDs need to fit in the
#dust opacities.

df = h5py.File(cfg.par.dustdir+cfg.par.dustfile,'r')
o = df['optical_properties']
df_nu = o['nu']
df_chi = o['chi']

df.close()


  


#add sources to hyperion
ad = pf.all_data()
stars_list,diskstars_list,bulgestars_list = sg.star_list_gen(boost,xcent,ycent,zcent,dx,dy,dz,pf,ad)
nstars = len(stars_list)




from source_creation import add_newstars,add_binned_seds,BH_source_add

if cfg.par.BH_SED == True: BH_source_add(m,pf,df_nu)


#figure out N_METAL_BINS:
fsps_metals = np.loadtxt(cfg.par.metallicity_legend)
N_METAL_BINS = len(fsps_metals)

if par.FORCE_BINNING == False:
    stellar_nu,stellar_fnu,disk_fnu,bulge_fnu = sg.allstars_sed_gen(stars_list,diskstars_list,bulgestars_list)
    m=add_newstars(df_nu,stellar_nu,stellar_fnu,disk_fnu,bulge_fnu,stars_list,diskstars_list,bulgestars_list,m)
    


else:
#note - the generation of the SEDs is called within
#add_binned_seds itself, unlike add_newstars, which requires
#that sg.allstars_sed_gen() be called first.
    
    m=add_binned_seds(df_nu,stars_list,diskstars_list,bulgestars_list,m)




nstars = len(stars_list)
nstars_disk = len(diskstars_list)
nstars_bulge = len(bulgestars_list)


   

    

'''
#EXPERIMENTAL FEATURES
if par.SOURCES_IN_CENTER == True:
    for i in range(nstars):
        stars_list[i].positions[:] =  np.array([xcent,ycent,zcent])
    for i in range(nstars_bulge):
        bulgestars_list[i].positions[:] =  np.array([xcent,ycent,zcent])
    for i in range(nstars_disk):
        diskstars_list[i].positions[:] = np.array([xcent,ycent,zcent])

if par.SOURCES_RANDOM_POSITIONS == True:
    print "================================"
    print "SETTING SOURCES TO RANDOM POSITIONS"
    print "================================"
    for i in range(nstars):
        xpos,ypos,zpos = np.random.uniform(-dx,dx),np.random.uniform(-dy,dy),np.random.uniform(-dz,dz)
        stars_list[i].positions[:] = np.array([xpos,ypos,zpos])
    for i in range(nstars_bulge):
        xpos,ypos,zpos = np.random.uniform(-dx,dx),np.random.uniform(-dy,dy),np.random.uniform(-dz,dz)
        bulgestars_list[i].positions[:] = np.array([xpos,ypos,zpos])
    for i in range(nstars_disk):
        xpos,ypos,zpos = np.random.uniform(-dx,dx),np.random.uniform(-dy,dy),np.random.uniform(-dz,dz)
        diskstars_list[i].positions[:] = np.array([xpos,ypos,zpos])
'''






print 'Done adding Sources'

print 'Setting up Model'
m_imaging = copy.deepcopy(m)

if cfg.par.SED == True:
    #set up the SEDs and images

    if cfg.par.SED_MONOCHROMATIC == True:

        
         #since all sources have the same spectrum just take the nu
         #from the input SED from the first source
        
        monochromatic_nu = m.sources[0].spectrum['nu']*u.Hz
        monochromatic_lam = (constants.c/monochromatic_nu).to(u.micron).value[::-1]
        ipdb.set_trace()
        if cfg.par.FIX_SED_MONOCHROMATIC_WAVELENGTHS == True:
            #idx = np.round(np.linspace(np.min(np.where(monochromatic_lam > cfg.par.SED_MONOCHROMATIC_min_lam)[0]),\
            ##                           np.max(np.where(monochromatic_lam < cfg.par.SED_MONOCHROMATIC_max_lam)[0]),\
            #                           cfg.par.SED_MONOCHROMATIC_nlam))


            idx = np.where( (monochromatic_lam > cfg.par.SED_MONOCHROMATIC_min_lam) & (monochromatic_lam < cfg.par.SED_MONOCHROMATIC_max_lam))[0]
            
            monochromatic_lam = np.take(monochromatic_lam,list(idx))

            ipdb.set_trace()

        m.set_monochromatic(True,wavelengths = monochromatic_lam)
        m.set_raytracing(True)
        m.set_n_photons(initial = par.n_photons_initial,
                                imaging_sources = par.n_photons_imaging,
                                imaging_dust =  par.n_photons_imaging,
                                raytracing_sources=par.n_photons_raytracing_sources,
                                raytracing_dust = par.n_photons_raytracing_dust)

        m.set_n_initial_iterations(3)
        m.set_convergence(True,percentile=99.,absolute=1.01,relative=1.01)
        sed = m.add_peeled_images(sed = True,image=False)
        
        sed.set_viewing_angles(np.linspace(0,90,par.NTHETA).tolist()*par.NPHI,np.repeat(np.linspace(0,90,par.NPHI),par.NPHI))
        sed.set_track_origin('basic')
   
        if cfg.par.SKIP_RT == False:
            m.write(model.inputfile+'.sed',overwrite=True)
            m.run(model.outputfile+'.sed',mpi=True,n_processes=par.n_MPI_processes,overwrite=True)

        print '[pd_front_end]: Beginning RT Stage: Calculating SED using a monochromatic spectrum equal to the input SED'

    else:
        
        m.set_raytracing(True)
        m.set_n_photons(initial=par.n_photons_initial,imaging=par.n_photons_imaging,
                        raytracing_sources=par.n_photons_raytracing_sources,raytracing_dust=par.n_photons_raytracing_dust)
        m.set_n_initial_iterations(7)
        m.set_convergence(True,percentile=99.,absolute=1.01,relative=1.01)
        

        sed = m.add_peeled_images(sed = True,image=False)
        sed.set_wavelength_range(2500,0.001,1000.)
        sed.set_viewing_angles(np.linspace(0,90,par.NTHETA).tolist()*par.NPHI,np.repeat(np.linspace(0,90,par.NPHI),par.NPHI))
        sed.set_track_origin('basic')
        
        print '[pd_front_end]: Beginning RT Stage: Calculating SED using a binned spectrum'
        #Run the Model
        if cfg.par.SKIP_RT == False:
            m.write(model.inputfile+'.sed',overwrite=True)
            m.run(model.outputfile+'.sed',mpi=True,n_processes=par.n_MPI_processes,overwrite=True)



#see if the variable exists to make code backwards compatible

if cfg.par.IMAGING == True:
    #read in the filters file
    filters = np.loadtxt(par.filter_file)
    print "Beginning Monochromatic Imaging RT"



    
    
    if cfg.par.IMAGING_TRANSMISSION_FILTER == False:
        m_imaging.set_monochromatic(True,wavelengths=filters)
        m_imaging.set_raytracing(True)
        m_imaging.set_n_photons(initial = par.n_photons_initial,
                                imaging_sources = par.n_photons_imaging,
                                imaging_dust =  par.n_photons_imaging,
                                raytracing_sources=par.n_photons_raytracing_sources,
                                raytracing_dust = par.n_photons_raytracing_dust)
       
    else:
        m_imaging.set_n_photons(initial=par.n_photons_initial,imaging=par.n_photons_imaging)

    m_imaging.set_n_initial_iterations(7)
    m_imaging.set_convergence(True,percentile=99.,absolute=1.01,relative=1.01)

    image = m_imaging.add_peeled_images(sed = True, image = True)
    if cfg.par.IMAGING_TRANSMISSION_FILTER == True:
        add_transmission_filters(image)
        
    image.set_viewing_angles(np.linspace(0,90,par.NTHETA).tolist()*par.NPHI,np.repeat(np.linspace(0,90,par.NPHI),par.NPHI))
    image.set_track_origin('basic')
    image.set_image_size(cfg.par.npix_x,cfg.par.npix_y)
    image.set_image_limits(-dx/2.,dx/2.,-dy/2.,dy/2.)
   
    if cfg.par.SKIP_RT == False:
        m_imaging.write(model.inputfile+'.image',overwrite=True)
        m_imaging.run(model.outputfile+'.image',mpi=True,n_processes=par.n_MPI_processes,overwrite=True)
   


    #Print a message in case that skip_rt debugging flag is set:
    print '++++++++++++++++++++++++++++++++++++'
    print 'WARNING: SKIP RT is set in the parameters_master file - this is why your code didnt run'
    print '++++++++++++++++++++++++++++++++++++'
        

#save SEDs
if par.STELLAR_SED_WRITE == True: stellar_sed_write(m)










